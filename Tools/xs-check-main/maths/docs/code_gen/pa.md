# Pseudo Assembly

This is the IR generated by the compiler for further compilation into byte code

## 1. PA Syntax

[//]: # (Todo: can values be casted to bools?)

1. Addressed Instruction ${\tt li} \rightarrow {\tt l : i}$
2. Addressed Instructions ${\tt lis} \rightarrow {\tt li}\ |\ {\tt li\ lis}$
3. Address ${\tt l} \rightarrow 1\ |\ 2\ |\ ...$
4. Instruction:

    $${\tt i} \rightarrow \quad {\tt d} \leftarrow {\tt s}\ |\ {\tt d} \leftarrow {\tt s\ op\ s}\ | \ {\tt ret}\ | \ {\tt ifn\ s\ goto\ l}\ |\ {\tt goto\ l}\ |\ {\tt push\ s}\ |\ {\tt pop\ d}\ |\ {\tt label}\ |\ {\tt jmp\ label}\ |\ {\tt d \leftarrow icast\ s}\ |\ {\tt d \leftarrow fcast\ s}\ |\ {\tt d \leftarrow scast\ s}\ |\ {\tt d \leftarrow malloc\ n}\ |\ {\tt free\ s}$$

5. Operator:

    $${\tt op} \rightarrow {\tt +\ |\ -\ |\ *\ |\ /\ |\ \%\ |\ <\ |\ >\ |\ <=\ |\ >=\ |\ ==\ |\ !=\ |\ \&\&\ |\ \texttt{||}}$$

    - Note: there are multiple variants of each operator for each type of input they support, denoted by a subscript: ${\tt op_i, op_f, op_b, op_s, op_v}$ for ${\tt int}$, ${\tt float}$, ${\tt bool}$, ${\tt string}$, and ${\tt vector}$ respectively. See [ยง 2.5. Operations](../../static/xs_type_chk/#25-operations "Type Checking > Operations") under [Type Checking](../../static/xs_type_chk/) for details.

6. Operand ${\tt d, s} \rightarrow {\tt c\ |\ r\ |\ v\ |\ mem[s]}$
7. Constant ${\tt c} \rightarrow {\tt LIT}$
8. Register ${\tt r} \rightarrow {\tt r_i}$
9. Identifier ${\tt v} \rightarrow {\tt x\ |\ y\ |\ ...}$

[//]: # (todo: can XS do unicode?)
Notes:

- ${\tt string}$s are implemented as a pointer to a memory address with a ${\tt u32}$ length prefix followed by that many ${\tt u8}$ values
- ${\tt vector}$s are implemented as a pointer to a memory address with three ${\tt f32}$ values for $x$, $y$, and $z$ respectively

## 2. PA Semantics & aliases

- PA assumes the availability of an infinite amount of identifiers (and memory) which are used like registers. Register allocation is deferred until bytecode generation.
- The availability of 32 enumerated 32-bit registers is assumed. The following aliases are used:
  - ${\tt r_{ret} = r_0}$: return value register
  - ${\tt r_{sp} = r_{27}}$: stack pointer
  - ${\tt r_{bp} = r_{28}}$: base pointer
  - ${\tt r_{lp} = r_{29}}$: link pointer
  - ${\tt r_{xp} = r_{30}}$: exception pointer
- The value of ${\tt r_{31}}$ is read-only and always $0$
- ${\tt alloc\ n}$ is a mnemonic alias for ${\tt r_{sp} \leftarrow r_{sp} + n}$
- ${\tt dealloc\ n}$ is a mnemonic alias for ${\tt r_{sp} \leftarrow r_{sp} - n}$
- A stack is maintained to support procedures.
- A heap is maintained for dynamic memory allocation.
- The ${\tt goto}$ instruction simply jumps to an address, whereas the ${\tt jmp}$ instruction jumps to a label and writes the current address to ${\tt r_{lp}}$
- ${\tt ret}$ jumps to the address in ${\tt r_{lp}} + 1$