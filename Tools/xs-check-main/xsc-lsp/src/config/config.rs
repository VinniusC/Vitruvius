use tower_lsp::lsp_types::ConfigurationItem;

use xsc_core::r#static::info::WarningKind;

use crate::config::ext_config::ExtConfig;
use crate::config::flavour::Flavour;

#[derive(Debug, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
struct JsonConfig {
    ignores: Vec<String>,
    extra_prelude_path: Option<String>,
    include_directories: Vec<String>,
    flavour: String,
}

pub async fn fetch_config(client: &tower_lsp::Client) -> anyhow::Result<ExtConfig> {
    let items = vec![ConfigurationItem {
        section: Some("xsc".to_string()),
        scope_uri: None,
    }];

    let config_values = client.configuration(items).await?;

    let Some(value) = config_values.get(0) else {
        anyhow::bail!("No configuration found");
    };
    let config: JsonConfig = serde_json::from_value(value.clone())?;

    let ignores = config.ignores.iter()
        .map(|s| {
            WarningKind::from_name(s)
                .expect("Error names generated by enum")
                .as_u32()
        })
        .collect();
    let extra_prelude_path = config.extra_prelude_path.and_then(|s| {
        if s == "" {
            None
        } else {
            Some(s.into())
        }
    });
    let include_dirs = config.include_directories.into_iter().map(|s| s.into()).collect();
    let flavour = Flavour::from_str(&config.flavour)
        .expect("Flavour name generated by enum");

    Ok(ExtConfig {
        ignores,
        extra_prelude_path,
        include_dirs,
        flavour,
    })
}